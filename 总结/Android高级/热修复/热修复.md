- [热修复](#热修复)
  - [热修复原理](#热修复原理)
    - [类加载机制](#类加载机制)
    - [双亲委派机制](#双亲委派机制)
    - [ClassLoader](#classloader)
    - [DexElements](#dexelements)
  - [热修复实践](#热修复实践)
## 热修复
### 热修复原理
热修复意思就是说不必重新发布新版本来修改线上的错误Bug, 可以通过服务器下发补丁apk到客户端，然后重新排DexElements数组，加载新的补丁类，通过类加载机制来避免再次加载已有的错误代码，实现Bug的热修复。这块就涉及到好些个概念，类加载机制，双亲委派机制，PathClassLoader, DexClassLoader, DexElements等，有了这些概念之后就可以建立起热修复的技术框架。

#### 类加载机制
类加载机制就是利用ClassLoader将Java的字节码文件，即.class文件从磁盘上加载到Java虚拟机内存中，然后进行一系列的加载，验证，准备，解析，初始化操作，然后将一个类的信息保存在Java虚拟机的方法区中。但是还有一些细节需要知道，这个ClassLoader具体在Java中是一个什么样的存在？

日常我们在开发中，写一个类，一般是通过Java系统的AppClassLoader来进行加载的，AppClassLoader是一个内部类，名字就叫应用程序类加载器，定义在JAVA_HOME的lib目录下rt.jar中的sun.misc.Launcher类中，负责加载的是程序员自己写的类的加载，其实还有其他三种类加载器，分别是BootstrapClassLoader, ExtClassLoader, CustomClassLoader(自定义类加载器)。BootstrapClassLoader是Java虚拟机自己实现的一个类加载器，用于加载启动类的加载，使用C++来实现的，它会加载系统的类，加载由系统变量"sun.boot.class.path"所指定的路径下的jar包，除了
启动类加载器之外，其他的类加载器都是用Java来实现的，因此我们不能用在程序中。ExtClassLoader是扩展类加载器，用于加载一些
JDK提供的扩展类，，它也定义在rt.jar中的sun.misc.Launcher类中，这个类加载器可以用在我们自己的程序中。自定义类加载器是我们自己继承抽象类ClassLoader, 实现loadClass方法，在该方法的最后通过defineClass方法一个类类型的对象来实现自定义类加载器。

上面讲了些关于类加载的知识，但是有一个问题，如果我们自己写了一个String类，那么就会与系统自带String冲突了，那么系统是怎么处理的呢？这里就是涉及到了双亲委派机制。

#### 双亲委派机制
双亲委派机制就是说加载一个类，一般向引入该类的加载器的父类加载器查找，如果父类加载器还有父类加载器，那么就会继续向上传递，直到查找到为止。如果没有找到，那么就由当前的类加载器进行加载。这么说来，类加载器是有一个优先级的，自定义的类加载器优先级最低，启动类加载器优先级最高，一般是从自定义类加载器或者应用程序类加载器开始，然后向上查找，扩展类加载器，启动类加载器，先向上传递，如果能够在启动类加载器中找到，那么就加载启动类加载器所能加载的类中去加载，那么最开始的那个类加载器所加载的那个类，就不会被加载。

![](http://luckyboy.oss-cn-beijing.aliyuncs.com/oss_file/1595915366431.png)

比如我们自己写了一个HelloWorld类，在加载这个类的时候，不管我们使用的是自定义的类加载器还是系统默认的AppClassLoader，它们都会首先将加载任务向上传递，先让上一层的类加载器尝试加载，一直传递到启动类加载器，启动类加载器会在系统变量"sun.boot.class.path"所指定的路径下查找是否有相应的类，如果有就会加载，如果没有就让下一层的类加载器加载，以此往下，直到最后一个类加载器都无法加载，那么就会抛出ClassNotFoundException，而如果我们自己写了一个和JDK提供的包名和类名一样的类时，那么在启动类加载器和扩展类加载器中，就会先把JDK提供的类加载器加载进来，进而保证了用户定义的类不会影响到JDK提供的类。

#### ClassLoader

#### DexElements

### 热修复实践

